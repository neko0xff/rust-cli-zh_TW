<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>輸出 - Rust 中的命令列應用程式</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">開始</a></li><li class="chapter-item expanded "><a href="../tutorial/index.html"><strong aria-hidden="true">1.</strong> 在15分鐘內建立一個命令列應用程式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> 專案初始化設置</a></li><li class="chapter-item expanded "><a href="../tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> 解析命令列參數</a></li><li class="chapter-item expanded "><a href="../tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> 首次運行</a></li><li class="chapter-item expanded "><a href="../tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> 合適的回饋錯誤</a></li><li class="chapter-item expanded "><a href="../tutorial/output.html" class="active"><strong aria-hidden="true">1.5.</strong> 輸出</a></li><li class="chapter-item expanded "><a href="../tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> 測試</a></li><li class="chapter-item expanded "><a href="../tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> 打包且發布一個Rust工具</a></li></ol></li><li class="chapter-item expanded "><a href="../in-depth/index.html"><strong aria-hidden="true">2.</strong> 深入探究主題</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> 訊號處理</a></li><li class="chapter-item expanded "><a href="../in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> 使用配置檔</a></li><li class="chapter-item expanded "><a href="../in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> 退出狀態碼</a></li><li class="chapter-item expanded "><a href="../in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> 與人互動</a></li><li class="chapter-item expanded "><a href="../in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> 與機器互動</a></li><li class="chapter-item expanded "><a href="../in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> 為你的 CLI 程式產生文件 </a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">3.</strong> 相關資源</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 中的命令列應用程式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="輸出"><a class="header" href="#輸出">輸出</a></h1>
<h2 id="在終端機下輸出-hello-world"><a class="header" href="#在終端機下輸出-hello-world">在終端機下輸出 “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>嗯，這很容易。</p>
<p>太好了，進入下一個主題。</p>
<h2 id="使用-println"><a class="header" href="#使用-println">使用 <code>println!</code></a></h2>
<p>您幾乎可以在終端機下使用 <code>println!</code> 巨集輸出所有您想輸出的東西。</p>
<p>這個巨集有一些非常驚人的功能，而且還有特殊的語法。
它希望您撰寫一個字串文字作為第一個參數，包含將要填入的佔位符號
再透過後面作為進一步參數的參數值。</p>
<p>範例:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>將會輸出</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>上面字串中的大括弧（ <code>{}</code> ）就是佔位符號中的一種。 
這是預設的佔位符號型別， 它嘗試以人類可讀的方式來輸出給定的參數的值。 
對於數值和字串，這會很好用， 
但並不是所有的型別都可以。 
這就是為什麼還有一個 “除錯表示(debug representation)”， 
你可以使用這個佔位符號來呼叫它 <code>{:?}</code>。</p>
<p>範例</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
<span class="boring">}
</span></code></pre></pre>
<p>將會輸出</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>如果你想在偵錯和記錄 中輸出自己建置的型別，
大部分情況下你可以在型別定義上新增 <code>#[derive(Debug)]</code> 屬性。</p>
<aside>
<p><strong>說明:</strong></p>
<p>“使用者友善(User-friendly)” 的輸出是使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> 特性完成的，
除錯輸出（適用於開發者）使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> 特徵。
您可以在 <code>println!</code> 中找到更多關於可以使用的語法的相關資訊。
在<a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html"><code>std::fmt</code>模組的文件</a>中。</p>
</aside>
<h2 id="輸出錯誤"><a class="header" href="#輸出錯誤">輸出錯誤</a></h2>
<p>輸出錯誤的部分應透過 stderr 完成， 
以便使用者和其它工具更方便的地將輸出通過管道傳輸到文件或更多的工具中。</p>
<aside>
<p><strong>說明:</strong>
在大部分作業系統中，
一個程式可以將輸出寫入至兩個串流中，<code>stdout</code> 和 <code>stderr</code>。 
<code>stdout</code> 用於程式的實際輸出，而 <code>stderr</code> 可將錯誤或其它資訊與 <code>stdout</code> 分開。 
這樣，
正確輸出的部分可以儲存到檔案或管道傳輸到其它程式中，同時將錯誤顯示給使用者。</p>
</aside>
<p>在 Rust 中，
使用 <code>println!</code> 和 <code>eprintln!</code>，
前者對應 <code>stdout</code> 和後者對應 <code>stderr</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>小心</strong>: </p>
<p>輸出 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">跳脫碼</a> 可能很危險，
會導致使用者的終端變成奇怪的狀態。 
手動輸出至終端時請務必小心使用！</p>
<p>當你處理原始<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">跳脫碼</a>時，
最好使用像 <code>ansi_term</code> 這樣的 <code>crate</code>， 
以便你（和你程式的使用者）更加放心。</p>
</aside>
<h2 id="關於輸出至終端的效能說明"><a class="header" href="#關於輸出至終端的效能說明">關於輸出至終端的效能說明</a></h2>
<p>輸出到終端時出奇的慢！ 
如果你在迴圈中呼叫 <code>println!</code> 之類的東西， 
它很容易成為其它運行速度快的程式的瓶頸。 
你可以做兩件事來為它提升速度。</p>
<p>首先，
你需要盡量減少實際「刷新」到終端的寫入次數。
<em>每次</em> 呼叫 <code>println!</code> 時，
它都會告訴系統刷新到終端，
因為輸出每個新行是很常見的。 
如果你不需要如此， 
你可以使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a> 來包裝一下 <code>stdout</code> 的句柄，
它的預設快取為 8 kB。 
( 當你想立即輸出至終端時，請在 <code>BufWriter</code> 上呼叫 <code>.flush()</code> 即可。)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>其次，
為 <code>stdout</code>（或 <code>stderr</code> ）申請一把鎖並使用 <code>writeln!</code> 來直接輸出至終端會很有用。 
它會阻止系統不停地鎖定並解鎖 <code>stdout</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>你也可以結合且使用這兩種方式。</p>
<h2 id="顯示進度條"><a class="header" href="#顯示進度條">顯示進度條</a></h2>
<p>有些 CLI 程式的運作時間很長，
會花費幾分鐘甚至數小時。 
如果你在撰寫這種程式，
你可能需要向使用者展示，其程式正在正常運作中。 
因此，你需要輸出有用的狀態更新訊息，
最好是使用易於使用的方式來進行輸出。</p>
<p>你可以使用 <a href="https://crates.io/crates/indicatif">indicatif</a> crate 來為你的程式加入進度條，
這是一個快速的例子：</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>細節部分可試著查看 indicatif 的 <a href="https://docs.rs/indicatif">相關文件</a> 和 <a href="https://github.com/console-rs/indicatif/tree/main/examples">範例</a> 。</p>
<h2 id="記錄檔"><a class="header" href="#記錄檔">記錄檔</a></h2>
<p>為了更方便了解我們的程式做了什麼，
我們需要為它加入一些記錄檔的相關語句，這很簡單。 
但在長時間後，例如半年後再執行這個程式時，
記錄檔就變得非常有用了。 
在某些方面來說， 
記錄的使用方法與 <code>println</code> 一樣類似，
只是它可以指定訊息的重要性（層級）。 
通常可以使用的層級包括 <em>error</em> , <em>warn</em>, <em>info</em> , <em>debug</em> , 和 <em>trace</em> 
（ <em>error</em> 優先順序最高， <em>trace</em> 最低）。</p>
<p>只需這兩樣東西，你就可以為你的程式加入簡單的記錄功能：
Log create（其中包含以記錄等級命名的巨集）和一個 <em>轉接器</em>， 
它會將記錄寫到有用的地方。 
記錄轉接器的使用是十分靈活的： 
例如，你可以不僅將記錄輸出至終端，同時也可寫進 <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> 或其它記錄伺服器。</p>
<p>因為我們現在最關心的是寫一個 CLI 程式，
所以選取一個易於使用的轉接器 <a href="https://crates.io/crates/env_logger">env_logger</a>。 
它之所以叫 <code>env</code> 記錄器，
因為你可以使用環境變數來指定程式中哪一部分需要記錄和記錄哪一個等級。 
它會在你的記錄資訊前加上時間戳記及所在模組資訊。 
由於函式庫也可以使用 <code>log</code>，你也可以輕鬆地配置它們的記錄輸出。</p>
<p>這是一個簡單的範例:</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}
</code></pre>
<p>如果你有 <code>src/bin/output-log.rs</code> 這個文件，
在 Linux 和 MacOS 上，您可以像這樣執行它：</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows PowerShell 中，您可以像這樣執行它：</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;info&quot;
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows CMD(命令提示字元) 中，您可以像這樣執行它：</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> 是設定 log 的環境變數名稱，
您可以使用它來設定記錄檔設定。
<code>env_logger</code> 還包含一個建置器，
因此你可以以程式設計的方式調整這些設置， 
例如，預設顯示 <em>info</em> 等級的記錄。</p>
<p>有很多替代的記錄器，
以及 <code>log</code> 的替代品或擴充功能。
如果您知道您的應用程式將有很多需要記錄的內容，
請確保檢查它們，
並讓您的使用者的生活更輕鬆。</p>
<aside>
<p><strong>貼士:</strong>
經驗表明，即使是用處不大的 CLI 程式，最終也會被使用多年。
( 特別是如果它們只是作為臨時解決方案的話 ）。
如果您的應用程式無法運行時，
而有人（例如將來的你）需要找出原因、
能夠透過 <code>--verbose</code> 獲得額外的記錄輸出
可以讓偵錯工作在幾分鐘和幾小時之間取得顯著效果。
<a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> create 包含了快速的
在使用 <code>clap</code> 的專案中新增 <code>--verbose</code> 的快速方法。</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/errors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../tutorial/testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/errors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../tutorial/testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
